全局安装TS：npm i typescript -g

前言：TypeScript本质上是为服务于js的类型便捷的，实际使用相当灵活，不用拘泥于绝对的规范，应根据实际情况进行调整

TypeScript类型：
- 特性：TypeScript使用强类型，不允许没有定义类型的声明，使用:声明类型
- 定义：
	- TS类型包含所有JS类型：null、undefined、string(小写)、number、boolean、object
	- 还包括void、never、enum、unknown、any以及自定义type和interface
- 变量声明：
	- var/let/const 标识符：数据类型=值
- 类型推导：
	- 如果没有明确声明类型，TS会隐式推导出一个类型，没有赋值则为any类型
	- null、undefined既是实际的值，也是类型
	- 数组：元素类型加上 \[]表示数组类型
		- const arr : number\[] = \[1,2,3]
		- const arr : (string|number) = \[1,2,"hello"]
	- 元组：已知元素数量和类型的数组
		- const tuple : \[number,string] = \[1,"hello"]
	- 对象：
		- 设置浅层对象，既不能修改对象数据，也不能新增数据(const obj:object={})
		- 设置深层对象从而限制属性类型(const obj:{name:string,age:string} = {name:'',age:''})
	- any、unknown、never：
		- 不标注类型，默认为any，在any身上做任何操作都是合法的
		- unknown类型类似于any，但unknown只能赋值给unknown或any
		- never表示永不存在值的类型，用于给异常或死循环值声明，never会在联合类型被移除
	- 函数：
		- 声明函数时，可在每个参数和返回值添加参数类型注解
		- 普通函数：function fn1(arg:number):number{ return 1}
		- 箭头函数：
			- const fn2 = (arg:number):number =>{ return 1}
			- const fn2 : (arg:number) =>number = arg=>{return 1}
			- 方法2适用于先定义函数类型type Fn2 = (arg:number) =>number后调用 
		- 调用签名：
			- 函数除了被调用，还可以有自己的属性值
			- interface Fn{attr:number , (msg:number) : void} 
		- 构造签名：使用new关键字将函数变为构造函数，即在调用签名前加new关键词
		- this：
			- 如果没有指定this类型，this是any类型
			- 可以在函数第一个参数声明this类型，函数调用的参数从第二个开始接收
			- ThisParameterType：提取函数类型的 this 参数类型，如果没有 this 参数则返回 unknown
			- OmitThisParameter：移除函数类型 this 参数类型，返回当前函数类型
	- 枚举类型：
		- 将一组可能出现的值，一个个列举，定义在一个类型中
		- enum Direction{left = ’Left‘，right = ’Right‘，other = 0}
	- 字面量类型：
		- 使用JS定义的值不仅可以做值，还可以当作TS类型
		- 样例：let msg：‘hello’ = ‘hello’
	- 类的类型：
		- 使用类不仅定义数据接口，也可应包括实现逻辑
		- 使用extends进行继承，使用super调用父类原型上的方法
		- 注：属性存在于类型实例中，方法在原型上，静态方法在类本身上
		- 成员修饰符(前缀)：public、protected、private、readonly
		- 抽象类(abstract class)：无法被实例化，只能被继承
		- 参数属性：语法糖，在构造函数中的属性将被转化为同名实例属性
- interface和type：
	- 定义：使用interface定义接口，使用type定义类型别名
	- 样例：
		- interface Ipoint{x:number,readonly y:number,z?:number }
		- type Point{x:number,y:number}
	- 区别：
		- interface只描述对象，type可以描述任何数据
		- interface使用extends实现继承，type使用&实现交叉类型
		- interface会创建新的类型名，type只是创建类型别名，并没有创建新的类型
		- interface可以重复声明拓展，type则不行
	- 接口索引签名：
		- 用来约束键值对对象
		- 样例：interface A1{ \[k:number]:string}
	- 接口继承：
		- 使用extends关键字实现接口继承
		- 样例：
			- interface Animal{name:string}
			- interface Dog extends Animal{age:number}
			- const dog:Dog = {name:'lili',age:11}
	- 接口实现：
		- 定义的接口可以被类实现
		- 在需要传入接口的地方也可以传入类实例
- 联合类型、交叉类型、函数重载：
	- TS有多种运算符，从现有的类型中创建新类型
	- 联合类型：多种类型满足一个即可，使用|符号，其中每个联合的类型被称为联合成员
	- 函数重载：用不同的方法编写同一个函数签名，表示函数可以用不同的方法调用
	- 交叉类型：满足多个类型的条件，使用&符号，若无满足值，则为never
- 断言：
	- 类型断言as，当TS无法获取到具体的类型信息，就需要使用类型断言
	- 非空类型断言！，当我们确定参数有值时，可使用非空类型断言跳过TS对其检测
	- 常量断言as const，相当于给类型收窄为readonly类型
- 类型兼容：
	- 参数多的对象可以赋值给参数少的对象
	- 参数少的函数可以赋值给参数多的函数
- 泛型编程：
	- 原理：通过尖括号传入泛型类型，根据该值进行类型统一化
	- 类型参数化：function fn\<T>(args:T):T{return args}
	- 注：1、函数、接口、类等都可以使用泛型编程；2、泛型类型可以指定默认值<\T = string>
	- 泛型约束：
		- extends：在泛型中使用extends可以约束泛型范围<\T extends string>
		- keyof：获取对象的键，用以生成一个联合类型，type Key = keyof Person
	- 映射类型：
		- 思想：遍历一个类型的所有属性，并为每个属性应用某种转换，用于从已有的类型中创建新的类型
		- 语法形式：{ \[K in keyof T]:U}
		- 其中，K是T所有类型的联合类型，U是变换函数
	- 内置工具和类型体操：
		- 条件类型：根据条件生成不同类型，类似于三元运算符
			- someType extends OtherType ？trueType：falseType
		- infer关键字：用以在正在比较的类型中推断类型
		- 分发条件类型：泛型中使用条件类型，如果传入联合类型，就会变成分发条件类型
		- Partitial<\Type>：所有属性变为可选属性?
		- Required<\Type>：所有属性变为必选属性
		- Readonly<\Type>：所有属性变为只读属性
		- Record<\keys,Type>：构建以所有key为键，Type为值的对象类型
		- Pick<\Type,keys>：从Type中选择keys类型构建新类型
		- Omit<\Type,keys>：从Type中去掉keys类型构建新类型
		- MyExclude<\UnionType，excludemenber>：从联合类型中过滤
		- Extract<\Union，Type>：从Union里提取可以赋给Type的类型
		- Exclude<\Union，Type>：从Union里剔除可以赋值给Type的类型
		- NonNullable<\Type>：排除所有null，undefined类型
	- 类型体操特性总结：
		- 索引类型：使用keyof关键字获取对象的所有键，形成一个新的联合类型，使用 \[]获取键对应的类型，T \[number]用于将数组所有类型构成联合类型，{}\[key of T]用于获取对象的所有键组成联合类型
		- 递归类型：在类型定义中引用了自身的类型，通常用于树形结构和递归结构
		- 联合类型和交叉类型：操作符‘|’和‘&’，联合类型类似于或，交叉类型用于合并多个类型为一个类型
		- 条件类型：使用extends关键字进行条件检索， 类型体操的核心，即根据条件返回特定类型，会对联合类型每一项进行条件检索，检索条件为符合检索规则，
		- 条件类型推断：通过infer关键字推断联合类型，最终会将结果合并为交叉类型
		- 映射类型：通过in关键字，使用 \[K in keyof T]的结构获取循环结构

TypeScript特性：
- 类型推断：TypeScript使用强类型，不允许没有定义类型的声明，使用:声明类型
- 接口：接口定义对象的形状，提高代码可读性与可维护性
	- 声明：interface User{name:string,age:number}
	- 使用：let user:User = {name,age}
		- let user:User = new CreateUser('name',age)
	- 注：使用时变量必须严格遵照接口的格式
- 组合类型推断：使用组合类型创建自定义类型，适用于复杂环境
	- type MyBool = true | false
	- type WindowState = "open"|"close"|"minimized"
	- let window:WindowState = "open"
- 泛型类型推断：自定义变量类型
	- interface BackPack\<Type>{
		- get(obj:Type)=>{}
	- }
	- declare const backpack:BackPack\<string>
	- backpack.get("aa")
- 元组声明：let point:\[number,number] = \[1,2]