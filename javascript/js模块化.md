背景：现代js开发经常会遇到代码量大和广泛使用三方依赖的问题，为了解决这个问题，需要把代码拆分为很多份，再通过某种方式联系起来。

模块模式：
- 基本思想：逻辑分块——各自封装——相互独立——自定义对外暴露内容/引入内容
- 模块标识符：一般来说，js使用文件路径作为模块标识符(node_module除外)，从而寻找对应模块
- 模块依赖：管理模块依赖是模块系统的核心，模块系统检视依赖并在本地初始化时加载所有依赖
- 模块加载：由于加载模块涉及其中代码，所以如果模块内部涉及别的模块，模块系统会递归加载所有模块
- 异步依赖：使用异步加载模块，提高性能
- 动态依赖：在代码执行过程中加载依赖，使其按需执行

模块加载器：
- 定义：用于将js代码和模块语法联系起来的模块工具
- CommonJS：
	- 导入方式：let moduleB = require('./moduleA') ：./moduleA为文件路径
	- 导出方式：module.exports = { name:value } ；module.exports.nameA = valueA
	- 特点：1、无论require()被引用多少次，模块始终是单例的，被导入模块只会被加载一次；2、模块会被缓存，后续只会调用缓存；3、模块导出可以为实体对象
- ES6模块规范：
	- 模块标签：
		- 方式：在script标签中添加type=“module”
		- 特点：会在代码执行到相应语句时加载模块内容
		- 作用：实现模块按需加载，从而实现作用域隔离与按需加载
	- ES6模块加载：
		- 特点：继承了commonJS和AMD的许多特性，包括单例化，模块只加载一次，只在加载后执行，同时保证模块异步加载
		- 模块判定：与script type = “module”或import语句相关的内容会被认为是模块
		- 模块导出：
			- 具名导出：export {moduleA，moduleB as default}
			- 默认导出：export default moduleD
