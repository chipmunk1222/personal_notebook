在`state`的章节我们介绍了“状态”在`react`应用中的位置，"状态"为应用在某一刻的数据集，而当“状态“发生改变时，`react`应用会重新渲染组件，本节中就来探讨下`react`应用中是如何进行状态管理的

# 响应式输入
## 声明式`ui`与命令式`ui`
在`react`中有两种描述`ui`的方法，分别是声明式和命令式，两者的区别在于
- 命令式：事无巨细地告诉组件每一步的动作操纵`ui`
- 声明式：定位“终点”，提供状态，过程让组件自行制导

>用开车的的例子就是，命令式是告诉司机每一个路口怎么转弯，而声明式则只需要告诉司机目的地，其余的都交给司机即可，显然，后者会有更大的优势
`react`中就是践行的声明式`ui`
## 如何实现声明式ui
具体工作流可以总结如下：
1. **定位**你的组件中不同的视图状态(**important**)
2. **确定**是什么触发了这些 state 的改变
3. **表示**内存中的 state（需要使用 `useState`）
4. **删除**任何不必要的 state 变量
5. **连接**事件处理函数去设置 state

# 组件间的状态共享
## 状态提升
在有关`State`的部分，我们提到过`react`中`state`的作用范围是有限的，而且仅限于最近顶层组件内，这就使得即使是相同的组件，多次渲染时内部`state`都是独立的，但这也会造成一些问题，例如如果我需要制作一个折叠屏组件，就无法达成单个组件显示的结果，这就需要用到我们的状态提升了，也就是将某些状态提升到父组件中

- 状态提升的方式非常简单，即将重用子组件的某个状态移到父组件中，由父组件单独设置，再作为`props`传递

于是衍生出了两种组件的概念：“受控组件”与“不受控组件”
- 受控组件：由`props`驱动的组件
- 不受控组件：由局部`state`驱动的组件

## 组件渲染保留机制
在对`state`的描述中，我们曾提到，`state`记忆状态时基于“快照”的，即只有组件重新渲染时，`state`才会更新，这是组件内部的动态修改造成的
这节要讲述的内容则描述了组件外部状态的改变，即**只有当在树中相同的位置渲染相同的组件时，React 才会一直保留着组件的 state**
换言之，当组件在`DOM`树中的位置更改时，其所拥有的`state`状态也会重置

另外，组件的重新渲染机制是基于"结果"的，也就是说，无论中间经历了怎样的判断，只要最终`UI`树里组件不变（`DOM`树不变），`state`重置机制就不会触发

有时当我们不想让这种渲染机制保留`state`的值，这时，我们提供了如下方法
- 将组件渲染在不同位置，用运算符替换基于`if`的条件渲染
- 在会造成渲染保留的组件上添加唯一标识符`key`