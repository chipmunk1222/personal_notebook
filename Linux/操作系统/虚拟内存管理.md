# 虚拟内存技术

## 概述
- 虚拟内存是一种内存管理技术，它使得每个进程都拥有一个虚拟的地址空间。这些虚拟地址空间可以独立于物理内存进行分配和管理。
- 虚拟内存通过硬件和软件的结合，使得程序员可以编写在有限内存资源上运行的大程序，而不必担心物理内存的限制。
- 虚拟地址空间限度取决于CPU逻辑地址容量

## 工作原理：
虚拟内存通过地址转换机制，将虚拟地址映射到物理地址。地址转换通常由内存管理单元（MMU）在硬件层面完成。MMU使用页表将虚拟地址翻译为物理地址。
简而言之，动态使用物理地址，通过展示页面的切换完成

- 页：虚拟内存和物理内存都划分为固定大小的块，称为页。通常，每页的大小是4KB。
- 页表：页表是存储虚拟地址到物理地址映射关系的数据结构。每个进程都有一个页表，用于管理其虚拟地址空间。

### 页表机制：
通过虚拟地址到物理地址的映射，当CPU访问虚拟地址时，自动将其转化为物理地址
- 虚拟地址：包含页号和偏移量
- 页表结构：存储从虚拟地址到物理地址映射关系的数据结构
- 地址转换：由内存管理单元（MMU）完成，MMU查找页表并将其翻译为物理地址

## 转化规则
- 提取页号和偏移量：从虚拟地址中提取出页号和页内偏移量
- 查找页表：查找页号对应页表项，找到物理内存页框号
- 计算物理地址：物理页框号+偏移量 = 最终物理地址
>验证规则：当虚拟页号小于页表中的limit限制，则转化无法完成
# 页面调度策略
决定物理内存和磁盘间的资源调度

>下列样例中，页面访问序列表示虚拟内存序列，数字表示页面编号，将其替换到物理内存中，下面例子默认页面窗格大小为3
>页面替换算法会自动检测已经存在的页面，因此不会出现重复页面共存的问题
>加载页面的过程称为页面错误（缺页fault）
## OPT算法：活跃替换（Optimal Page Replacement）
- 理想最优算法，选择那些在未来最长时间内不会被访问的页面（需要预先知道页面访问频率，故只存在于理想情况）替换
- 示例：
	- 页面访问序列为：7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2
	- 替换过程：2->7(7页面出现次数最少)
## FIFO算法：先进先出（First In, First Out）
- 先进先出算法，不考虑页面是否被访问过
- 会造成`belady`异常现象
- 重复出现时不会刷新时间戳
- 示例：
	- 页面访问序列为：7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2
	- 替换过程：2->7（7最先进入，最先替换）

## LRU算法：频率替换（Least Recently Used）
- 选择最近使用最少的页面
- 选择方式是从当前节点往前数最晚到达的节点
- 示例：
	- 页面访问序列为：7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2
	- 替换过程：2->7（目前频率都为0，依序选择7）
- 实现LRU算法的两种方式
	- Counter计时器法：为每个页面添加一个计时器，每当调用该页面时启用计时器，根据页面计时器大小决定替换的页面
	- Stack堆栈法：维护一个栈数据结构，每当有新页面调用时，将其移动到栈顶，从而刷新页面最后访问时间，以此寻找最后调用页面
## clock算法：时钟算法（second choice algorithm）
- 添加一个对页面的指针，指针依序遍历物理内存，遍历则-1，每次访问页面时指针引用值＋1，找到引用值为0时便替换，并将指针后移
- 示例：
	- 页面访问序列为：7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2
	- 替换过程：2->7（开始全为1，遍历一轮全为0）
	- 0->0(替换后0引用值为1，其他都为0)
	- 3->1（依此类推）
